# 과외_관리_통합_플랫폼_-_기능_명세서_v2_4

## 문서 개요

본 문서는 과외 관리 통합 플랫폼의 모든 기능을 상세히 정의합니다.
각 기능의 목적, 동작 방식, 에러 처리, 권한 제어, 사용자 시나리오, 개발 우선순위를 포함합니다.

**v2.4 주요 변경사항:** ⭐ NEW

- F-006 과외비 자동 정산 시스템 딥링크 결제 추가
    - Phase 1 MVP 딥링크 기반 외부 결제 플로우 명세 (2.6.9.1 섹션 신규 추가)
    - 토스/카카오페이 딥링크 URL 구조 정의
    - 결제 완료/실패 시 앱 복귀 로직 상세화
    - React Native 딥링크 핸들링 코드 예시 추가
    - Django 백엔드 API 구현 예시 추가
    - 딥링크 핸들링 에러 케이스 7개 추가
    - API 엔드포인트 2개 추가 (결제 링크 생성, 결제 결과 처리)
    - 보안 고려사항 4가지 명시
    - 구현 체크리스트 24개 항목 추가

**v2.3 주요 변경사항:** ⭐ NEW
- F-002 스케줄 관리 시스템 상세화
- 반복 일정 시스템 상세 명세 추가 (매주, 격주 등)
- 보강 일정 조율 프로세스 상세화 (제안/승인)
- 일정 충돌 감지 로직 추가
- 캘린더 뷰 옵션 추가 (월간/주간/일간)
- API 엔드포인트 예시 추가
- F-003 출결 관리 시스템 상세화
- 출결 체크 플로우 상세 명세
- 출결 수정 정책 명확화 (체크 후 1시간 이내만 수정 가능)
- 월별 출결 리포트 자동 생성 시스템 추가
- 정산 시스템 연동 로직 상세화 (출석 100%, 지각 80%, 결석 0%)
- 자동 결석 처리 로직 추가 (수업 30분 경과 시)
- F-006 과외비 자동 정산 시스템 대폭 상세화
- 3단계 구현 전략 상세 명세 (MVP/결제 통합/에스크로)
- 정산 계산 로직 상세 추가 (출결 기반 자동 계산)
- 분쟁 해결 메커니즘 추가
- 법적 요구사항 섹션 추가 (영수증 발급, 세금계산서)
- Phase 1 MVP 범위 재확인 및 강조 (결제 기능 제외)
- 데이터 모델 상세 명세 추가
- API 엔드포인트 예시 8개 추가
- Celery 비동기 작업 명세 추가 (월초 자동 정산 생성)
- 스케줄/출결/정산 상세 설계서 내용 통합
- WBS 연동을 위한 구현 체크리스트 명확화

**v2.2 주요 변경사항:** ⭐ NEW
- F-001 회원 관리 및 매칭 기능 대폭 상세화
- 삼자 관계 구조 다이어그램 추가
- 초대 코드 시스템 상세 명세 (6자리, 7일 만료, 2회 사용)
- 회원가입 플로우 단계별 상세 설명
- 이메일 인증 프로세스 추가
- 권한 관리 체계 매트릭스 추가
- API 엔드포인트 예시 추가
- 데이터 모델 상세 명세
- UI/UX 화면 예시 추가
- 에러 케이스 확장 (11개 → 12개)
- 그룹 탈퇴 및 계정 삭제 정책 추가

**v2.1 주요 변경사항:**
- F-006 과외비 자동 정산 기능의 MVP 범위 명확화
- 앱 내 결제 기능 제외 (Phase 2로 이관)
- 정산 확인 프로세스 강조 (양측 확인 → 영수증 발급)
- 오프라인 결제 방식 명시

**v2.0 주요 변경사항:**
- 모든 MVP 핵심 기능에 에러 케이스 추가
- F-004 교재 진도율 동기화에 권한별 접근 제어 명시
- 알림 트리거 맵 확장 (에러 상황 및 실패 케이스 포함)
- F-010 감정 알림 기능 완전 제거 (사용자 수요 검증 실패)
- 기능 ID 재정렬

---

## 1. 사용자 유형 및 권한 체계

플랫폼은 세 가지 사용자 유형을 지원하며, 각 유형별로 차별화된 권한과 기능을 제공합니다.

### 1.1 과외 선생님

**역할**: 교육 제공자 및 주요 데이터 생성자

**권한**
- 수업 일정 생성 및 수정
- 출결 체크 (출석/지각/결석 기록)
- 진도 및 수업 내용 기록
- 교재 등록 및 진도 입력
- 숙제 부여 및 확인
- 피드백 작성
- 정산 내역 조회 및 영수증 발급

**제한 사항**
- 과외비 결제 기능 없음 (조회만 가능)
- 학생의 숙제 제출물 삭제 불가
- 확정된 정산 금액 임의 수정 불가

### 1.2 학생

**역할**: 학습 당사자 및 일부 데이터 생성자

**권한**
- 수업 일정 조회
- 숙제 제출
- 오답 태그 등록
- 본인의 학습 대시보드 조회
- 진도 및 피드백 조회

**제한 사항**
- 수업 일정 수정 불가 (조회만)
- 출결 기록 수정 불가
- 정산 내역 조회 불가
- 교재 진도 입력 불가 (조회만)

### 1.3 학부모

**역할**: 모니터링 및 의사결정권자

**권한**
- 자녀의 모든 학습 데이터 조회
- 출결 현황, 진도율, 피드백 열람
- 과외비 정산 내역 확인 및 결제
- 일정 변경 요청 (최종 결정은 선생님)
- 과외 선생님과 채팅 소통

**제한 사항**
- 학습 데이터 직접 입력 및 수정 불가
- 숙제 대신 제출 불가
- 출결 기록 수정 불가
- 교재 진도 입력 불가

---

## 2. 핵심 기능 상세

### 2.1 회원 관리 및 매칭

**기능 ID**: F-001

**개발 우선순위**: 1단계 MVP (필수)

**관련 문서**: [WeTee_회원관리_및_매칭_시스템_상세_설계서.md]

**기능 목적**
사용자 유형별로 차별화된 가입 경로와 권한 체계를 구축하여 이후 모든 기능의 기반을 마련합니다. 과외의 핵심인 **선생님-학생-학부모 삼자 관계**를 안전하고 명확하게 연결하는 것이 이 기능의 최우선 목표입니다.

### 2.1.1 핵심 문제 정의

**해결하고자 하는 문제**
- 기존 과외 매칭 플랫폼은 매칭 후 관리 기능이 없음
- 학습 관리 앱은 선생님-학생-학부모 삼자 관계를 고려하지 않음
- 메신저나 수기 관리는 권한 제어와 데이터 관리가 불가능

**WeTee의 해결 방안**
- 삼자 관계를 하나의 “과외 그룹”으로 명확히 정의
- 초대 코드 기반의 안전한 연결 시스템
- 사용자 유형별 차별화된 권한과 화면 제공

### 2.1.2 시스템 아키텍처

**삼자 관계 구조**

```
선생님 (Teacher)
    │
    ├─ 과외 그룹 생성
    ├─ 초대 코드 발급: ABC123 (6자리)
    │
    ▼
TutoringGroup (과외 그룹)
    │
    ├─ teacher_id → 선생님
    ├─ student_id → 학생 (초대 코드로 가입)
    ├─ parent_id  → 학부모 (초대 코드로 가입)
    │
    └─ 그룹 완성 조건: 3명 모두 가입 완료
```

**그룹 형성 프로세스**

```
Step 1: 선생님 가입
┌──────────────┐
│   선생님     │ → 회원가입 → 그룹 생성 → 초대 코드 발급
└──────────────┘                           │
                                           │ (ABC123, 7일 만료)
Step 2: 학생 가입                          ▼
┌──────────────┐                    ┌─────────────┐
│    학생      │ → 초대 코드 입력 →  │    그룹     │
└──────────────┘    (ABC123)        │ (선생님+학생)│
                                    └─────────────┘
                                           │
Step 3: 학부모 가입                        │
┌──────────────┐                          ▼
│   학부모     │ → 초대 코드 입력 →  ┌──────────────┐
└──────────────┘    (ABC123)        │  완성된 그룹  │
                                    │(선생님+학생  │
                                    │  +학부모)    │
                                    └──────────────┘
```

### 2.1.3 초대 코드 시스템 상세

**초대 코드 규칙**
- **형식**: 6자리 영문 대문자 + 숫자 조합 (예: A3B9C2, X7Y2Z5)
- **유효기간**: 생성 후 7일
- **사용 제한**: 최대 2회 (학생 1회 + 학부모 1회)
- **중복 방지**: 데이터베이스 유니크 제약

**초대 코드 생성 알고리즘**

```python
import secrets
import string
def generate_invite_code():
    """안전한 6자리 초대 코드 생성"""    characters = string.ascii_uppercase + string.digits
    code = ''.join(secrets.choice(characters) for _ in range(6))
    return code
```

**초대 코드 검증 로직**

```
검증 단계:
1. 코드 존재 확인 (DB 조회)
2. 만료 여부 확인 (생성일 + 7일 < 현재시각)
3. 사용 횟수 확인 (used_count < 2)
4. 역할별 중복 확인 (학생이 이미 있는데 학생으로 가입 시도 시 거부)

통과 → 그룹 자동 연결
실패 → 에러 메시지 및 대응 안내
```

**초대 코드 재발급**
- 선생님은 언제든지 새로운 초대 코드 재발급 가능
- 재발급 시 기존 코드는 즉시 무효화
- 사용 횟수 초기화

### 2.1.4 회원가입 플로우 상세

**A. 과외 선생님 회원가입 (4단계)**

**Step 1: 기본 정보 입력**

```
입력 항목:
- 이메일 (필수, 유니크)
- 비밀번호 (필수, 8자 이상, 영문+숫자+특수문자)
- 비밀번호 확인 (필수)
- 이름 (필수)
- 전화번호 (필수, 한국 형식 010-XXXX-XXXX)
- 약관 동의 (필수)

검증:
- 이메일 중복 확인
- 비밀번호 강도 검사
- 전화번호 형식 검증
```

**Step 2: 이메일 인증**

```
프로세스:
1. 가입 시 인증 메일 자동 발송
2. 사용자가 이메일의 인증 링크 클릭
3. email_verified = True로 업데이트
4. 로그인 가능하지만 일부 기능 제한

* 미인증 시 제한 사항:
  - 알림 수신 불가
  - 정산 기능 사용 불가
```

**Step 3: 프로필 등록**

```
입력 항목 (선택):
- 학력/전공 (예: 서울대학교 수학과)
- 경력 연수
- 자기소개
- 가르치는 과목 (다중 선택)
- 시간당 수업료 (기본값)

저장 후 메인 화면으로 이동
```

**Step 4: 과외 그룹 생성**

```
자동 실행:
- TutoringGroup 생성
- 초대 코드 자동 발급
- 화면에 초대 코드 표시

선생님 액션:
- 초대 코드를 학생/학부모에게 공유 (카카오톡, 문자 등)
```

**B. 학생 회원가입 (3단계)**

**Step 1: 초대 코드 입력**

```
화면:
- 초대 코드 입력 필드 (6자리)
- "확인" 버튼

검증 API 호출:
GET /api/v1/tutoring/groups/verify-invite/?code=ABC123

응답:
{
  "valid": true,
  "group_name": "김민수 학생 수학 과외",
  "teacher_name": "홍길동",
  "subject": "수학",
  "expires_at": "2025-10-31T23:59:59Z"
}

* 유효한 코드면 Step 2로 진행
* 무효면 에러 메시지 표시
```

**Step 2: 기본 정보 입력**

```
입력 항목:
- 이메일 (필수)
- 비밀번호 (필수)
- 이름 (필수)
- 전화번호 (필수)
- 초대 코드 (자동 입력됨, 수정 불가)

회원가입 완료 시:
- User 생성 (user_type='student')
- 자동으로 그룹에 연결 (TutoringGroup.student_id 업데이트)
- invite_code_used_count += 1
```

**Step 3: 학생 프로필 등록**

```
입력 항목 (선택):
- 학년 (초1~고3, 재수생 등)
- 학교명
- 학습 목표
- 관심 분야

저장 후 학생 전용 홈 화면으로 이동
```

**C. 학부모 회원가입**

학생과 동일한 프로세스이지만 `user_type='parent'`로 설정됩니다.

**그룹 완성 확인**

```
조건: student_id AND parent_id 모두 존재

완성 시:
- group.is_complete = True
- 선생님에게 "그룹이 완성되었습니다" 알림 전송
- 모든 기능 활성화
```

### 2.1.5 데이터 모델 상세

**User 모델** (Django AbstractUser 확장)

```python
class User(AbstractUser):
    user_type = CharField(choices=['teacher', 'student', 'parent'])
    phone = CharField(max_length=20)
    email_verified = BooleanField(default=False)
    created_at = DateTimeField(auto_now_add=True)
    updated_at = DateTimeField(auto_now=True)
```

**Profile 모델** (유형별 확장)

```python
class TeacherProfile(Model):
    user = OneToOneField(User)
    education = TextField()  # 학력    major = CharField()  # 전공    experience_years = IntegerField()  # 경력    bio = TextField()  # 자기소개    subjects = JSONField()  # 가르치는 과목    default_hourly_rate = IntegerField()  # 기본 시간당 수업료class StudentProfile(Model):
    user = OneToOneField(User)
    grade = CharField()  # 학년    school = CharField()  # 학교    goal = TextField()  # 학습 목표    interests = JSONField()  # 관심 분야class ParentProfile(Model):
    user = OneToOneField(User)
    relationship = CharField()  # 관계 (부, 모, 기타)    occupation = CharField(null=True)  # 직업 (선택)
```

**TutoringGroup 모델**

```python
class TutoringGroup(Model):
    teacher = ForeignKey(User, related_name='teaching_groups')
    student = ForeignKey(User, related_name='learning_group', null=True)
    parent = ForeignKey(User, related_name='parent_group', null=True)
    name = CharField()  # 그룹 이름    subject = CharField()  # 주 과목    invite_code = CharField(unique=True, max_length=6)
    invite_code_expires_at = DateTimeField()
    invite_code_used_count = IntegerField(default=0)
    is_complete = BooleanField(default=False)
    created_at = DateTimeField(auto_now_add=True)
    def generate_invite_code(self):
        """초대 코드 생성 메서드"""        # 구현 내용...
```

### 2.1.6 권한 관리 체계

**권한 매트릭스**

| 작업 | 선생님 | 학생 | 학부모 | 비고 |
| --- | --- | --- | --- | --- |
| 그룹 생성 | ✅ | ❌ | ❌ | 선생님만 가능 |
| 초대 코드 발급 | ✅ | ❌ | ❌ | 그룹 생성 시 자동 |
| 초대 코드 재발급 | ✅ | ❌ | ❌ | 언제든지 가능 |
| 초대 코드로 가입 | ❌ | ✅ | ✅ | 학생/학부모만 |
| 그룹 정보 조회 | ✅ | ✅ | ✅ | 모두 가능 |
| 그룹 정보 수정 | ✅ | ❌ | ❌ | 그룹명, 주 과목 |
| 그룹 탈퇴 | ⚠️ | ⚠️ | ⚠️ | 모두 가능하나 주의 필요 |

**권한 검증 예시**

```python
# Django REST Framework Permission Classclass IsTeacher(BasePermission):
    def has_permission(self, request, view):
        return request.user.user_type == 'teacher'class IsGroupMember(BasePermission):
    def has_object_permission(self, request, view, obj):
        # obj는 TutoringGroup 인스턴스        return (request.user == obj.teacher or
                request.user == obj.student or
                request.user == obj.parent)
```

### 2.1.7 API 엔드포인트

**회원가입 API**

```
POST /api/v1/auth/register/teacher/
POST /api/v1/auth/register/student/
POST /api/v1/auth/register/parent/

Request Body (공통):
{
  "email": "user@example.com",
  "password": "SecurePass123!",
  "password_confirm": "SecurePass123!",
  "first_name": "길동",
  "last_name": "홍",
  "phone": "010-1234-5678",
  "terms_agreed": true,
  "privacy_agreed": true,

  // 학생/학부모는 추가 필드
  "invite_code": "ABC123"  // 필수
}

Response (201 Created):
{
  "user_id": 1,
  "user_type": "teacher",
  "email": "user@example.com",
  "message": "회원가입이 완료되었습니다."
}
```

**로그인 API**

```
POST /api/v1/auth/login/

Request:
{
  "email": "user@example.com",
  "password": "SecurePass123!"
}

Response (200 OK):
{
  "access": "eyJ0eXAiOiJKV1QiLCJh...",
  "refresh": "eyJ0eXAiOiJKV1QiLCJh...",
  "user": {
    "id": 1,
    "email": "user@example.com",
    "user_type": "teacher",
    "name": "홍길동",
    "email_verified": true
  }
}
```

**초대 코드 검증 API**

```
GET /api/v1/tutoring/groups/verify-invite/?code=ABC123

Response (200 OK):
{
  "valid": true,
  "group_name": "김민수 학생 수학 과외",
  "teacher_name": "홍길동",
  "subject": "수학",
  "available_roles": ["student", "parent"],
  "expires_at": "2025-10-31T23:59:59Z"
}

Response (400 Bad Request - 만료):
{
  "valid": false,
  "error": "EXPIRED",
  "message": "초대 코드가 만료되었습니다."
}
```

**그룹 생성 및 초대 코드 발급 API**

```
POST /api/v1/tutoring/groups/

Request:
{
  "name": "김민수 학생 수학 과외",
  "subject": "수학"
}

Response (201 Created):
{
  "group_id": 1,
  "name": "김민수 학생 수학 과외",
  "invite_code": "ABC123",
  "invite_code_expires_at": "2025-10-31T23:59:59Z",
  "message": "과외 그룹이 생성되었습니다. 초대 코드를 학생과 학부모에게 공유하세요."
}
```

**초대 코드 재발급 API**

```
POST /api/v1/tutoring/groups/{group_id}/regenerate-invite/

Response (200 OK):
{
  "invite_code": "X9Y2Z7",
  "expires_at": "2025-11-07T23:59:59Z",
  "message": "새로운 초대 코드가 발급되었습니다."
}
```

### 2.1.8 이메일 인증 시스템

**인증 프로세스**

```
1. 회원가입 시 email_verified = False
2. 인증 메일 발송 (토큰 포함 링크)
3. 사용자가 링크 클릭
4. GET /api/v1/auth/verify-email/?token=abc123
5. 토큰 검증 후 email_verified = True
6. 인증 완료 페이지 표시
```

**인증 메일 템플릿**

```
제목: [WeTee] 이메일 인증을 완료해주세요

안녕하세요, 홍길동 선생님!

WeTee 가입을 환영합니다.
아래 버튼을 클릭하여 이메일 인증을 완료해주세요.

[이메일 인증하기]
https://wetee.com/verify-email?token=abc123...

링크는 24시간 동안 유효합니다.
```

**미인증 시 제한 사항**
- ❌ 정산 기능 사용 불가
- ❌ 알림 수신 불가
- ✅ 로그인 가능
- ✅ 데이터 조회 가능

### 2.1.9 UI/UX 요구사항

**공통 원칙**
- 회원가입은 **3단계 이내**로 완료
- 각 단계는 30초 이내 작성 가능
- 진행 표시바로 현재 위치 표시
- 뒤로가기 시 입력 데이터 보존

**사용자 유형 선택 화면**

```
┌─────────────────────────┐
│    WeTee에 오신 것을     │
│      환영합니다!        │
├─────────────────────────┤
│                         │
│  ┌─────────────────┐   │
│  │  👨‍🏫 과외 선생님  │   │
│  └─────────────────┘   │
│                         │
│  ┌─────────────────┐   │
│  │  👨‍🎓 학생        │   │
│  └─────────────────┘   │
│                         │
│  ┌─────────────────┐   │
│  │  👪 학부모       │   │
│  └─────────────────┘   │
│                         │
│  이미 계정이 있으신가요?  │
│  [로그인]                │
└─────────────────────────┘
```

**초대 코드 입력 화면** (학생/학부모)

```
┌─────────────────────────┐
│   초대 코드를 입력하세요  │
├─────────────────────────┤
│                         │
│  선생님이 보내주신       │
│  6자리 코드를 입력해주세요│
│                         │
│  ┌─┬─┬─┬─┬─┬─┐      │
│  │A│B│C│1│2│3│      │
│  └─┴─┴─┴─┴─┴─┘      │
│                         │
│  [확인]                  │
│                         │
│  초대 코드가 없으신가요?  │
│  선생님에게 요청해주세요  │
└─────────────────────────┘
```

**초대 코드 공유 화면** (선생님)

```
┌─────────────────────────┐
│   초대 코드가 발급되었습니다│
├─────────────────────────┤
│                         │
│  학생과 학부모에게        │
│  아래 코드를 공유하세요   │
│                         │
│  ┌─────────────────┐   │
│  │   ABC123        │   │
│  │   (7일간 유효)   │   │
│  └─────────────────┘   │
│                         │
│  [카카오톡으로 공유]     │
│  [문자로 공유]           │
│  [코드 복사]             │
│                         │
│  만료되면 새 코드를       │
│  재발급할 수 있습니다     │
└─────────────────────────┘
```

### 2.1.10 에러 케이스 및 처리

| 에러 상황 | 에러 메시지 | 처리 방법 | 에러 코드 |
| --- | --- | --- | --- |
| 이미 존재하는 이메일 | “이미 가입된 이메일입니다” | 로그인 화면으로 이동 제안 | EMAIL_EXISTS |
| 잘못된 초대 코드 | “초대 코드가 올바르지 않습니다” | 다시 입력 요청, 3회 실패 시 선생님에게 문의 안내 | INVALID_CODE |
| 초대 코드 만료 | “초대 코드가 만료되었습니다” | 선생님에게 새 코드 요청 안내 | CODE_EXPIRED |
| 초대 코드 사용 완료 | “이 초대 코드는 이미 모두 사용되었습니다” | 선생님에게 새 코드 요청 안내 | CODE_EXHAUSTED |
| 이미 그룹에 속한 사용자 | “이미 다른 과외 그룹에 속해 있습니다” | 기존 그룹 탈퇴 후 재가입 안내 | ALREADY_IN_GROUP |
| 이메일 인증 실패 | “인증 메일을 확인해주세요” | 인증 메일 재발송 버튼 제공 | EMAIL_NOT_VERIFIED |
| 비밀번호 불일치 | “비밀번호가 일치하지 않습니다” | 비밀번호 확인란 재입력 요청 | PASSWORD_MISMATCH |
| 약한 비밀번호 | “더 강력한 비밀번호를 사용해주세요” | 비밀번호 규칙 안내 (8자 이상, 영문+숫자+특수문자) | WEAK_PASSWORD |
| 전화번호 형식 오류 | “올바른 전화번호 형식이 아닙니다” | 010-XXXX-XXXX 형식 안내 | INVALID_PHONE |
| 네트워크 오류 | “네트워크 연결을 확인해주세요” | 재시도 버튼 제공 | NETWORK_ERROR |
| 서버 오류 | “일시적인 오류가 발생했습니다” | 잠시 후 재시도 안내 | SERVER_ERROR |
| 초대 코드 재발급 실패 | “초대 코드 재발급에 실패했습니다” | 재시도 버튼, 문의 안내 | CODE_REGENERATE_FAILED |
| 그룹 탈퇴 제한 (정산 미완료) | “정산되지 않은 과외비가 있어 탈퇴할 수 없습니다” | 정산 완료 후 탈퇴 안내 | PENDING_PAYMENT |

### 2.1.11 추가 고려사항

**그룹 탈퇴**

```
탈퇴 가능 조건:
- 미정산 과외비 없음
- 예정된 수업 없음 (또는 취소 완료)

탈퇴 시 영향:
- 해당 그룹의 모든 데이터 접근 불가
- 재가입 시 새 초대 코드 필요
- 과거 데이터는 아카이브 (선택 구현)

주의사항:
- 선생님 탈퇴 시 그룹 전체 해산
- 학생/학부모 탈퇴 시 그룹 불완전 상태로 전환
```

**계정 삭제**

```
삭제 가능 조건:
- 모든 그룹에서 탈퇴 완료
- 정산 완료

삭제 시 처리:
- 개인정보 즉시 삭제 (GDPR 준수)
- 학습 데이터는 익명화 후 보관 (통계 목적)
- 재가입 시 새 계정으로 간주
```

**다중 그룹 관리** (선생님만)

```
Phase 1 (MVP):
- 선생님은 여러 그룹 관리 가능
- 그룹 전환 UI 제공 (드롭다운 또는 탭)

Phase 2 (확장):
- 대시보드에서 모든 그룹 통합 조회
- 그룹별 필터링 및 정렬
```

**보안 고려사항**

```
✅ 비밀번호 해싱: bcrypt 또는 Argon2
✅ JWT 토큰 만료: Access 1시간, Refresh 7일
✅ HTTPS 필수 (모든 API 요청)
✅ Rate Limiting: 로그인 시도 5회/분
✅ SQL Injection 방지: ORM 사용
✅ XSS 방지: 입력값 이스케이핑
```

---

### 2.2 실시간 수업 스케줄 관리

**기능 ID**: F-002

**개발 우선순위**: 1단계 MVP (필수)

**기능 목적**
과외 일정의 불확실성과 소통 비용을 줄이고, 일정 변경이나 보강을 투명하게 관리합니다.

**기능 설명**
과외 선생님, 학생, 학부모가 공유하는 캘린더를 통해 정규 수업 일정을 설정하고, 변경 시 실시간 알림을 전송합니다.

**상세 동작**

1. 정규 수업 일정 등록
    - 선생님이 요일, 시간, 장소 입력
    - 반복 설정 (매주 월/수 7시 등)
    - 저장 시 학생과 학부모에게 자동 알림
2. 일정 변경 및 취소
    - 선생님이 특정 날짜 수업 취소
    - 취소 사유 입력 (선택)
    - 즉시 푸시 알림 전송
3. 보강 일정 조율
    - 선생님이 보강 가능 날짜 2-3개 제안
    - 학부모가 앱에서 확인 후 선택
    - 확정 시 캘린더에 자동 반영
4. 캘린더 뷰
    - 월간/주간 뷰 전환 가능
    - 확정 수업 (파란색), 취소 (회색), 보강 (주황색) 색상 구분

**권한별 접근 제어**

| 작업 | 선생님 | 학생 | 학부모 |
| --- | --- | --- | --- |
| 일정 생성 | ✅ | ❌ | ❌ |
| 일정 조회 | ✅ | ✅ | ✅ |
| 일정 수정 | ✅ | ❌ | ❌ |
| 일정 취소 | ✅ | ❌ | ❌ |
| 보강 제안 | ✅ | ❌ | ❌ |
| 보강 승인 | ❌ | ❌ | ✅ |
| 일정 변경 요청 | ❌ | ❌ | ✅ (메시지 전송) |

**UI/UX 요구사항**
- 캘린더는 월간 뷰가 기본
- 일정 클릭 시 상세 정보 팝업
- 일정 변경은 3클릭 이내

**데이터 모델**
- Schedule 테이블: id, group_id, date, time, duration, status, cancellation_reason, created_by, is_recurring, recurring_pattern_id
- RecurringPattern 테이블: id, schedule_id, frequency, day_of_week, start_date, end_date

### 2.2.1 반복 일정 시스템

**반복 유형**
- 매주 특정 요일 (예: 매주 월/수 7시)
- 격주 특정 요일
- 특정 날짜 범위 내 반복

**데이터 모델**

```python
class RecurringPattern(Model):
    schedule = ForeignKey(Schedule)
    frequency = CharField(choices=['weekly', 'biweekly'])
    day_of_week = IntegerField()  # 0=월, 6=일    start_date = DateField()
    end_date = DateField(null=True)  # None이면 무한 반복
```

### 2.2.2 보강 일정 조율 프로세스

**프로세스**

```
1. 선생님: 수업 취소 + 보강 날짜 2-3개 제안
2. 앱: 학부모에게 푸시 알림 전송
3. 학부모: 제안된 날짜 중 선택
4. 앱: 선생님에게 승인 알림 + 캘린더 자동 반영
```

**UI 플로우**
- 선생님: “수업 취소” → “보강 제안하기” → 날짜 2-3개 선택
- 학부모: 푸시 알림 → 앱 열기 → 제안 확인 → 날짜 선택
- 확정: 양측 캘린더에 자동 추가

### 2.2.3 알림 시스템

**수업 전 리마인더**
- 1시간 전 알림 (기본)
- 1일 전 알림 (설정 가능)
- 사용자별 알림 on/off

**일정 변경 알림**
- 일정 생성: “새로운 수업이 등록되었습니다”
- 일정 변경: “수업 시간이 변경되었습니다”
- 일정 취소: “수업이 취소되었습니다”

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 중복 일정 등록 | “이미 해당 시간에 수업이 있습니다” | 기존 일정 표시, 시간 변경 제안 |
| 과거 날짜 등록 시도 | “과거 날짜는 등록할 수 없습니다” | 오늘 이후 날짜 선택 요청 |
| 수업 시작 1시간 전 취소 시도 | “수업 1시간 전에는 취소가 어렵습니다. 긴급 취소하시겠습니까?” | 확인 팝업 표시, 긴급 취소 알림 강화 |
| 알림 전송 실패 | 내부 로그 기록 | 재전송 시도 (최대 3회), 실패 시 앱 내 알림으로 대체 |
| 보강 일정 중복 승인 | “이미 승인된 보강 일정입니다” | 확정된 일정 표시 |
| 네트워크 오류로 저장 실패 | “일정 저장에 실패했습니다” | 로컬에 임시 저장, 네트워크 복구 시 자동 동기화 |

---

### 2.3 출결 관리 시스템

**기능 ID**: F-003

**개발 우선순위**: 1단계 MVP (필수)

**기능 목적**
출결 관리를 자동화하여 분쟁을 방지하고, 출석률 데이터를 정산 및 학습 분석의 기초 자료로 활용합니다.

**기능 설명**
과외 선생님이 수업 시작 시 출석/지각/결석을 기록하면 즉시 저장되고 학부모에게 알림이 전송됩니다.

**상세 동작**

1. 출결 체크
    - 수업 예정 시간 30분 전부터 체크 가능
    - 출석/지각/결석 버튼 중 하나 선택
    - 지각 선택 시 지각 시간 입력 (분 단위)
    - 결석 선택 시 사유 입력 (선택)
2. 실시간 알림
    - 출석 체크 즉시 학부모에게 푸시 알림
    - “자녀가 7시 수업에 출석했습니다”
3. 출결 기록 조회
    - 월별 출석률 통계
    - 출석/지각/결석 횟수 집계
    - 출결 히스토리 타임라인
4. 출결 리포트
    - 월말 자동 생성
    - 출석률, 지각률, 결석률 그래프
    - PDF 다운로드 가능

**권한별 접근 제어**

| 작업 | 선생님 | 학생 | 학부모 |
| --- | --- | --- | --- |
| 출결 체크 | ✅ | ❌ | ❌ |
| 출결 조회 | ✅ | ✅ | ✅ |
| 출결 수정 (체크 후 1시간 이내) | ✅ | ❌ | ❌ |
| 출결 수정 (1시간 경과 후) | ❌ | ❌ | ❌ |
| 출결 리포트 생성 | 자동 | - | - |
| 출결 리포트 다운로드 | ✅ | ❌ | ✅ |

**UI/UX 요구사항**
- 출결 체크는 1탭으로 완료
- 큰 버튼 (손가락으로 쉽게 누를 수 있게)
- 체크 완료 시 확인 애니메이션

**데이터 모델**
- Attendance 테이블: id, schedule_id, status, late_minutes, absence_reason, checked_at, checked_by, modified_at, can_modify
- AttendanceReport 테이블: id, group_id, month, year, total_sessions, attended, late, absent, attendance_rate, pdf_url

### 2.3.1 출결 체크 플로우 상세

**체크 시간 제한**
- 수업 30분 전부터 체크 가능
- 수업 종료 후 2시간까지 체크 가능
- 2시간 경과 후 체크 시 “사후 체크” 표시

**출결 수정 정책**
- 체크 후 1시간 이내만 수정 가능
- 1시간 경과 후에는 수정 불가
- 이의가 있을 경우 관리자 문의 필요

### 2.3.2 월별 출결 리포트

**자동 생성**
- 매월 1일 0시에 전월 리포트 자동 생성
- 출석률, 지각률, 결석률 계산
- PDF 형식으로 저장

**리포트 내용**
- 월별 출결 통계 (출석/지각/결석 횟수)
- 출석률 그래프
- 일자별 출결 상세 내역
- 지각 시간 누적 통계

### 2.3.3 정산 시스템 연동

**과외비 부과 로직**
- 출석: 100% 부과
- 지각 (10분 이상): 80% 부과
- 결석 (사전 취소): 0% 부과
- 결석 (무단): 100% 부과 (정책 설정 가능)

**연동 프로세스**

```
1. 매월 1일: 전월 출결 데이터 집계
2. 출결 상태별 과외비 자동 계산
3. 정산 내역에 출결 데이터 포함
4. 선생님/학부모에게 정산 알림
```

**비즈니스 로직**
- 수업 시작 시간 기준 10분 이내 도착 = 출석
- 10분 초과 = 지각
- 체크 안 하고 수업 시간 30분 경과 = 자동 결석 처리 (옵션)

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 중복 출결 체크 시도 | “이미 출결이 체크되었습니다” | 기존 출결 상태 표시, 수정 버튼 제공 (1시간 이내) |
| 일정 없이 출결 체크 시도 | “등록된 수업 일정이 없습니다” | 일정 먼저 등록 안내 |
| 수업 시간 30분 전 조기 체크 | “아직 출결 체크 시간이 아닙니다” | 체크 가능 시간 안내 |
| 수업 종료 2시간 후 체크 시도 | “수업 시간이 많이 지났습니다. 그래도 체크하시겠습니까?” | 확인 팝업, 사후 체크로 기록 |
| 네트워크 오류로 체크 실패 | “출결 체크에 실패했습니다” | 로컬에 임시 저장, 네트워크 복구 시 자동 전송 |
| 알림 전송 실패 | 내부 로그 기록 | 재전송 시도, 실패 시 앱 내 알림으로 표시 |
| 출결 수정 권한 없음 (1시간 경과) | “출결 체크 후 1시간이 지나 수정할 수 없습니다” | 학부모/운영자에게 문의 안내 |

---

### 2.4 교재 진도율 동기화

**기능 ID**: F-004

**개발 우선순위**: 2단계 확장 기능

**기능 목적**
학습 과정의 블랙박스화를 해소하고, 객관적인 데이터로 학습 진행 상황을 공유합니다.

**기능 설명**
과외 선생님이 수업 후 다룬 교재, 페이지, 단원을 입력하면 실시간으로 공유되고 진도율이 자동 계산됩니다.

**상세 동작**

1. 교재 등록
    - 교재명, 출판사, 총 페이지 수 입력
    - 과외 그룹당 여러 교재 등록 가능
2. 진도 기록
    - 수업 후 오늘 다룬 페이지 범위 입력
    - 예: 수학의 정석 72-85페이지
    - 단원명 입력 (선택)
    - 저장 시 자동으로 진도율 계산
3. 진도율 계산
    - 현재까지 다룬 페이지 수 / 전체 페이지 수 × 100
    - 예: 72페이지 / 300페이지 = 24%
4. 예상 완료 시점 계산
    - 최근 4주간 평균 진도 속도 계산
    - 남은 페이지 / 주당 평균 페이지 = 예상 완료 주차
5. 진도 시각화
    - 교재별 프로그레스 바
    - 주차별 진도 그래프
    - 단원별 학습 완료 체크리스트

**권한별 접근 제어**

| 작업 | 선생님 | 학생 | 학부모 |
| --- | --- | --- | --- |
| 교재 등록 | ✅ | ❌ | ❌ |
| 교재 조회 | ✅ | ✅ | ✅ |
| 교재 수정/삭제 | ✅ | ❌ | ❌ |
| 진도 입력 | ✅ | ❌ | ❌ |
| 진도 조회 | ✅ | ✅ | ✅ |
| 진도 수정 (입력 후 24시간 이내) | ✅ | ❌ | ❌ |
| 진도 삭제 | ✅ (입력 후 24시간 이내) | ❌ | ❌ |
| 진도율 그래프 조회 | ✅ | ✅ | ✅ |

**비고**:
- 선생님만 교재와 진도를 생성/수정할 수 있습니다
- 학생과 학부모는 모든 진도 정보를 조회만 가능합니다
- 진도 수정은 입력 후 24시간 이내로 제한하여 데이터 무결성 보장

**UI/UX 요구사항**
- 진도 입력은 30초 이내 완료 가능하게
- 자주 쓰는 교재는 즐겨찾기
- 진도율은 대시보드 메인에 표시

**데이터 모델**
- Textbook 테이블: id, group_id, name, publisher, total_pages
- Progress 테이블: id, textbook_id, schedule_id, start_page, end_page, chapter, recorded_at

**비즈니스 로직**
- 중복 페이지 입력 방지 (경고 메시지)
- 총 페이지 초과 입력 방지

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 중복 페이지 입력 | “이미 다룬 페이지입니다 (72-80p)” | 경고 표시, 그래도 진행 옵션 제공 |
| 총 페이지 초과 입력 | “교재의 총 페이지(300p)를 초과할 수 없습니다” | 입력값 수정 요청 |
| 시작 페이지 > 끝 페이지 | “시작 페이지가 끝 페이지보다 클 수 없습니다” | 입력값 확인 요청 |
| 교재 미등록 상태에서 진도 입력 | “먼저 교재를 등록해주세요” | 교재 등록 화면으로 이동 |
| 권한 없는 사용자의 진도 입력 시도 | “선생님만 진도를 입력할 수 있습니다” | 조회 모드로 전환 |
| 24시간 경과 후 수정 시도 | “입력 후 24시간이 지나 수정할 수 없습니다” | 새로운 진도로 입력 안내 |
| 네트워크 오류로 저장 실패 | “진도 저장에 실패했습니다” | 로컬 임시 저장, 재시도 버튼 제공 |

---

### 2.5 수업 직후 기록 시스템

**기능 ID**: F-005

**개발 우선순위**: 1단계 MVP (필수)

**기능 목적**
수업 내용을 체계적으로 기록하여 학습의 연속성을 확보하고, 장기적인 학습 이력을 관리합니다.

**기능 설명**
과외 선생님이 수업 종료 직후 오늘 수업 내용, 학생 이해도, 다음 계획을 템플릿 형식으로 기록합니다.

**상세 동작**

1. 수업 기록 템플릿
    - 오늘 배운 내용: (텍스트 입력)
    - 학생 이해도: (5점 척도 선택)
    - 특이사항: (텍스트 입력, 선택)
    - 다음 수업 계획: (텍스트 입력, 선택)
2. 빠른 입력
    - 자주 쓰는 문구 저장 기능
    - 음성 입력 지원 (STT)
    - 작성 시간 3분 이내 목표
3. 자동 연결
    - 출결, 진도, 숙제 데이터와 자동 연결
    - 하나의 수업 세션으로 통합 표시
4. 타임라인 뷰
    - 최근 수업부터 역순 정렬
    - 날짜별 아코디언 형태
    - 검색 및 필터 기능

**권한별 접근 제어**

| 작업 | 선생님 | 학생 | 학부모 |
| --- | --- | --- | --- |
| 수업 기록 작성 | ✅ | ❌ | ❌ |
| 수업 기록 조회 | ✅ | ✅ | ✅ |
| 수업 기록 수정 | ✅ (작성 후 48시간 이내) | ❌ | ❌ |
| 수업 기록 삭제 | ❌ | ❌ | ❌ |

**UI/UX 요구사항**
- 수업 종료 후 “수업 기록하기” 알림
- 템플릿은 커스터마이징 가능
- 저장 후 즉시 학생/학부모에게 공유

**데이터 모델**
- SessionRecord 테이블: id, schedule_id, content, understanding_level, notes, next_plan, recorded_at

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 출결 체크 없이 기록 시도 | “먼저 출결을 체크해주세요” | 출결 체크 화면으로 이동 |
| 중복 기록 시도 | “이미 수업 기록이 작성되었습니다” | 기존 기록 표시, 수정 옵션 제공 |
| 필수 항목 누락 | “수업 내용을 입력해주세요” | 누락된 필드 강조 표시 |
| 음성 인식 실패 | “음성 인식에 실패했습니다” | 다시 시도 또는 수동 입력 제안 |
| 네트워크 오류로 저장 실패 | “수업 기록 저장에 실패했습니다” | 로컬 임시 저장, 나중에 자동 동기화 |
| 48시간 경과 후 수정 시도 | “작성 후 48시간이 지나 수정할 수 없습니다” | 관리자 문의 안내 |

---

### 2.6 과외비 자동 정산

**기능 ID**: F-006

**개발 우선순위**: 1단계 MVP (최우선)

**관련 문서**: [WeTee_과외비_자동_정산_시스템_상세_설계서.md]

**기능 목적**
과외비 정산의 투명성을 확보하고 금전적 분쟁을 예방합니다. 출결 기록 기반 자동 계산으로 신뢰도를 높입니다.

### 2.6.1 핵심 문제 정의

**전형적인 분쟁 시나리오**

```
선생님: "이번 달 총 4회 수업했습니다. 20만원입니다."
학부모: "어? 3회 아니었나요? 한 번은 취소했잖아요."
선생님: "그건 나중에 보강했어요."
학부모: "...기억이 안 나는데요?"
→ 불편한 대화, 신뢰 하락, 관계 악화
```

**WeTee의 해결 방안**
- 모든 수업이 출결 시스템에 기록됨
- 정산 내역서에 수업 일자별 상세 기록 표시
- 객관적 데이터 기반으로 분쟁 예방

### 2.6.2 3단계 구현 전략

**Phase 1: MVP (1-2개월) - 계산 및 확인**

✅ **포함 기능**:
- 출결 기록 기반 자동 정산 계산
- 월별 정산 내역서 생성 (수업 상세 리스트)
- 선생님/학부모 양측 확인 인터페이스
- 정산 내역 PDF 생성 및 공유
- 영수증 자동 발급
- 이의 제기 기능 (메시지/채팅 연동)

❌ **제외 기능**:
- 실제 결제 기능 (PG 연동)
- 자동 입금
- 에스크로

**결제 처리 방식** (딥링크 기반 외부 결제):

- 앱 내에서 "결제하기" 버튼 클릭 → 외부 결제 링크 생성
- 토스/카카오페이로 이동하여 결제 진행 (딥링크)
- 결제 완료 후 WeTee 앱으로 자동 복귀 (딥링크 `wetee://payment/callback`)
- 정산 화면에 결제 상태 자동 반영
- 대체 수단: 계좌이체/현금 (오프라인)도 지원
- 상세 내용은

**2.6.9.1 딥링크 기반 결제 플로우**섹션 참조

**Phase 1의 장점**:
- 개발 시간 50% 단축 (PG 연동 생략)
- PG사 수수료 0원
- 법적 리스크 최소화
- 핵심 가치(투명성)에 집중
- 사업자등록 없이도 서비스 시작 가능

**Phase 2: 결제 통합 (3-6개월 이후)**
- 결제 게이트웨이 연동 (토스페이먼츠 권장)
- 카드/계좌이체 결제
- 자동 정산 및 입금

**Phase 3: 에스크로 (6-12개월 이후)**
- 안전거래 시스템
- 플랫폼 임시 보관 → 수업 완료 확인 → 선생님 정산
- 금융 규제 검토 필요

### 2.6.3 정산 계산 로직

**기본 계산식**

```
월별 총 과외비 = Σ(개별 수업 과외비)

개별 수업 과외비 = 기본 시간당 과외비 × 수업 시간(시간) × 출석 상태별 비율

출석 상태별 비율:
- 출석: 100%
- 지각 (10분 이상): 80%
- 결석 (사전 취소): 0%
- 결석 (무단): 100% (정책 설정 가능, 기본값 0%)
```

**예시 계산**

```
기본 정보:
- 시간당 과외비: 50,000원
- 수업 시간: 2시간
- 월 총 수업: 4회

계산:
1회차: 출석 → 50,000 × 2 × 100% = 100,000원
2회차: 지각 15분 → 50,000 × 2 × 80% = 80,000원
3회차: 결석 (사전 취소) → 50,000 × 2 × 0% = 0원
4회차: 출석 → 50,000 × 2 × 100% = 100,000원

월 총액: 280,000원
```

### 2.6.4 자동 정산 생성 프로세스

**Celery 비동기 작업**

```python
# 매월 1일 0시 자동 실행@periodic_task(run_every=crontab(day_of_month='1', hour=0, minute=0))
def generate_monthly_payments():
    """전월 정산 자동 생성"""    last_month = get_last_month()
    groups = TutoringGroup.objects.filter(is_complete=True)
    for group in groups:
        # 출결 데이터 검증        if not validate_attendance_data(group, last_month):
            notify_teacher_missing_attendance(group)
            continue        # 정산 계산        payment = calculate_monthly_payment(group, last_month)
        # 정산 생성        Payment.objects.create(payment_data)
        # 알림 전송        notify_payment_generated(group)
```

**자동 생성 조건**
- 모든 수업에 출결 체크 완료
- 과외비 설정 완료 (시간당 요금)
- 그룹이 활성 상태

**실패 시 처리**
- 선생님에게 알림 전송 (“출결 미체크 수업 있음”)
- 24시간 후 재시도
- 3회 실패 시 수동 처리 필요

### 2.6.5 양측 확인 프로세스

**확인 플로우**

```
1. 정산 생성 → 선생님/학부모에게 알림
2. 선생님 확인 (정산 내역 검토 후 승인)
3. 학부모 확인 (정산 내역 검토 후 승인)
4. 양측 모두 확인 → 영수증 자동 발급
5. 한쪽이 이의 제기 → 분쟁 상태로 변경
```

**상태 관리**
- `pending`: 생성됨, 확인 대기
- `teacher_confirmed`: 선생님 확인 완료
- `parent_confirmed`: 학부모 확인 완료
- `confirmed`: 양측 확인 완료 (영수증 발급)
- `disputed`: 이의 제기됨
- `resolved`: 분쟁 해결됨

### 2.6.6 분쟁 해결 메커니즘

**이의 제기 프로세스**
1. 선생님/학부모가 “이의 제기” 버튼 클릭
2. 이의 사유 입력 (필수)
3. 문제가 되는 수업 선택
4. 상대방에게 즉시 알림 전송
5. 48시간 내 대화로 해결 권장
6. 미해결 시 관리자 중재 요청 가능

**분쟁 해결 방법**
- 채팅/메시지로 직접 소통
- 출결 기록 재확인
- 필요 시 관리자 개입
- 해결 시 정산 금액 수정 또는 유지

### 2.6.7 영수증 자동 발급

**발급 시점**
- 양측 확인 완료 시 자동 발급

**영수증 내용**
- 발급 번호 (고유 ID)
- 발급 일자
- 선생님 정보 (이름)
- 학부모 정보 (이름, 학생명)
- 과목
- 정산 기간 (예: 2025년 10월)
- 수업 상세 내역 (일자, 시간, 출석 상태, 금액)
- 총 금액

**PDF 생성**
- ReportLab 라이브러리 사용
- S3에 업로드
- Presigned URL로 다운로드 링크 제공
- 유효기간: 30일

### 2.6.8 데이터 모델

**PaymentSetting (정산 설정)**

```python
class PaymentSetting(Model):
    group = OneToOneField(TutoringGroup)
    hourly_rate = IntegerField()  # 시간당 과외비    attendance_charge_rate = IntegerField(default=100)  # 출석 부과율 (%)    late_charge_rate = IntegerField(default=80)  # 지각 부과율 (%)    absence_charge_rate = IntegerField(default=0)  # 결석 부과율 (%)    no_show_charge_rate = IntegerField(default=0)  # 무단 결석 부과율 (%)
```

**Payment (정산)**

```python
class Payment(Model):
    group = ForeignKey(TutoringGroup)
    month = IntegerField()  # 1-12    year = IntegerField()
    total_amount = IntegerField()
    status = CharField(choices=STATUS_CHOICES)
    teacher_confirmed_at = DateTimeField(null=True)
    parent_confirmed_at = DateTimeField(null=True)
    generated_at = DateTimeField(auto_now_add=True)
    is_confirmed_by_both = BooleanField(default=False)
```

**PaymentDetail (정산 상세)**

```python
class PaymentDetail(Model):
    payment = ForeignKey(Payment)
    session = ForeignKey(Schedule)  # 수업 일정    attendance = ForeignKey(Attendance)  # 출결 기록    session_date = DateField()
    duration_hours = DecimalField()
    base_fee = IntegerField()  # 기본 과외비    charge_rate = IntegerField()  # 적용 비율 (%)    charged_amount = IntegerField()  # 실제 부과 금액
```

**Receipt (영수증)**

```python
class Receipt(Model):
    payment = OneToOneField(Payment)
    receipt_number = CharField(unique=True)
    issued_to = ForeignKey(User)  # 학부모    issued_by = ForeignKey(User)  # 선생님    issued_at = DateTimeField(auto_now_add=True)
    pdf_url = URLField()
    purpose = CharField(default='교육비')
```

**PaymentDispute (정산 이의)**

```python
class PaymentDispute(Model):
    payment = ForeignKey(Payment)
    raised_by = ForeignKey(User)  # 이의 제기자    reason = TextField()
    disputed_sessions = ManyToManyField(Schedule)  # 문제 수업    status = CharField(choices=['pending', 'resolved'])
    resolution = TextField(null=True)
    created_at = DateTimeField(auto_now_add=True)
    resolved_at = DateTimeField(null=True)
```

### 2.6.9 API 엔드포인트

**정산 조회**

```
GET /api/v1/payments/
GET /api/v1/payments/{id}/
GET /api/v1/payments/{id}/details/
```

**정산 확인**

```
POST /api/v1/payments/{id}/confirm/
Body: { "note": "확인했습니다" }
```

**이의 제기**

```
POST /api/v1/payments/{id}/dispute/
Body: {
  "reason": "10월 15일 수업은 취소했는데 부과되었습니다",
  "disputed_session_ids": [123, 124]
}
```

**영수증 다운로드**

```
GET /api/v1/payments/{id}/receipt/
Response: { "pdf_url": "https://..." }
```

**수동 정산 생성**

```
POST /api/v1/payments/manual-generate/
Body: {
  "group_id": 1,
  "month": 10,
  "year": 2025
}
```

### 2.6.9.1 딥링크 기반 결제 플로우 ⭐ NEW (v2.4)

**기능 목적**

Phase 1 MVP에서는 PG 연동 없이 **외부 결제 서비스(토스/카카오페이)의 딥링크**를 활용하여 간편 결제를 구현합니다. 사용자는 앱에서 벗어나지 않는 듯한 자연스러운 경험을 제공받습니다.

---

## 전체 플로우

```
1. 학부모가 정산 화면에서 "결제하기" 버튼 클릭
   ↓
2. 백엔드: 외부 결제 링크 생성 (토스/카카오페이 URL + 딥링크 콜백)
   ↓
3. 프론트엔드: 생성된 URL을 외부 브라우저/앱으로 오픈
   ↓
4. 사용자: 토스/카카오페이에서 결제 진행
   ↓
5. 결제 완료: 외부 서비스가 WeTee 딥링크 호출
   ↓
6. WeTee 앱 복귀: 정산 화면으로 자동 이동
   ↓
7. 결제 상태 확인 API 호출 → UI 업데이트
```

---

## 딥링크 URL 스키마

WeTee 앱이 처리할 딥링크 URL 구조:

```
wetee://payment/callback?payment_id={payment_id}&status={status}&transaction_id={transaction_id}

파라미터:
- payment_id: 정산 ID (필수)
- status: success | failure | cancelled (필수)
- transaction_id: 외부 결제 거래 ID (선택)
```

**예시**

```
성공: wetee://payment/callback?payment_id=123&status=success&transaction_id=toss_abc123
실패: wetee://payment/callback?payment_id=123&status=failure
취소: wetee://payment/callback?payment_id=123&status=cancelled
```

---

## 외부 결제 링크 생성

백엔드에서 생성하는 토스/카카오페이 결제 URL:

### 토스페이 예시

```
https://pay.toss.im/web/checkout?...
  &successUrl=wetee://payment/callback?payment_id=123&status=success
  &failUrl=wetee://payment/callback?payment_id=123&status=failure
```

### 카카오페이 예시

```
https://kapi.kakao.com/payment/ready?...
  &approval_url=wetee://payment/callback?payment_id=123&status=success
  &fail_url=wetee://payment/callback?payment_id=123&status=failure
  &cancel_url=wetee://payment/callback?payment_id=123&status=cancelled
```

---

## 프론트엔드 처리 (React Native)

### 1. 결제 링크 오픈

```jsx
import { Linking } from 'react-native';// 결제 링크 생성 API 호출const response = await api.post(`/api/v1/payments/${paymentId}/create-payment-link/`, {
  provider: 'toss', // 'toss' | 'kakaopay'  amount: 280000});const { payment_url } = response.data;// 외부 브라우저/앱으로 결제 링크 오픈await Linking.openURL(payment_url);
```

### 2. 딥링크 수신 핸들링

```jsx
import { useEffect } from 'react';import { Linking } from 'react-native';useEffect(() => {
  // 앱 실행 시 딥링크 체크  Linking.getInitialURL().then(handleDeepLink);  // 앱 실행 중 딥링크 수신  const subscription = Linking.addEventListener('url', (event) => {
    handleDeepLink(event.url);  });  return () => subscription.remove();}, []);const handleDeepLink = async (url) => {
  if (!url || !url.startsWith('wetee://payment/callback')) return;  // URL 파라미터 파싱  const params = parseDeepLinkParams(url);  const { payment_id, status, transaction_id } = params;  // 결제 결과 처리 API 호출  try {
    await api.post(`/api/v1/payments/${payment_id}/handle-payment-callback/`, {
      status,      transaction_id
    });    // 정산 화면으로 이동    navigation.navigate('PaymentDetail', { id: payment_id });    // 성공 메시지 표시    if (status === 'success') {
      Alert.alert('결제 완료', '과외비가 정상적으로 결제되었습니다.');    }
  } catch (error) {
    Alert.alert('오류', '결제 처리 중 오류가 발생했습니다.');  }
};
```

### 3. URL 파라미터 파싱 헬퍼 함수

```jsx
const parseDeepLinkParams = (url) => {
  try {
    const urlObj = new URL(url);    const params = {};    for (const [key, value] of urlObj.searchParams) {
      params[key] = value;    }
    return params;  } catch (error) {
    console.error('Deep link parsing error:', error);    return {};  }
};
```

### 4. 결제 수단 선택 UI

```jsx
import { Modal, TouchableOpacity, Text, View, Alert } from 'react-native';const PaymentMethodModal = ({ visible, onClose, paymentId }) => {
  const handlePayment = async (provider) => {
    try {
      // 결제 링크 생성      const response = await api.post(
        `/api/v1/payments/${paymentId}/create-payment-link/`,        { provider }
      );      const { payment_url } = response.data;      // 외부 앱 실행 가능 여부 확인      const canOpen = await Linking.canOpenURL(payment_url);      if (canOpen) {
        onClose();        await Linking.openURL(payment_url);      } else {
        // 앱 미설치 시 처리        Alert.alert(
          '앱 설치 필요',          `${provider === 'toss' ? '토스' : '카카오페이'} 앱이 필요합니다.`,          [
            { text: '취소', style: 'cancel' },            {
              text: '설치하기',
              onPress: () => {
                const storeUrl = provider === 'toss'                  ? Platform.select({
                      ios: 'https://apps.apple.com/kr/app/toss/id839333328',                      android: 'https://play.google.com/store/apps/details?id=viva.republica.toss'                    })
                  : Platform.select({
                      ios: 'https://apps.apple.com/kr/app/kakaopay/id1464496236',                      android: 'https://play.google.com/store/apps/details?id=com.kakaopay.app'                    });                Linking.openURL(storeUrl);              }
            }
          ]
        );      }
    } catch (error) {
      Alert.alert('오류', '결제 링크 생성에 실패했습니다.');      console.error('Payment link creation error:', error);    }
  };  return (
    <Modal visible={visible} transparent animationType="slide">      <View style={styles.modalContainer}>        <View style={styles.modalContent}>          <Text style={styles.modalTitle}>결제 수단 선택</Text>          <TouchableOpacity
            style={styles.paymentButton}
            onPress={() => handlePayment('toss')}
          >            <Text style={styles.buttonText}>토스페이로 결제</Text>          </TouchableOpacity>          <TouchableOpacity
            style={styles.paymentButton}
            onPress={() => handlePayment('kakaopay')}
          >            <Text style={styles.buttonText}>카카오페이로 결제</Text>          </TouchableOpacity>          <TouchableOpacity
            style={styles.cancelButton}
            onPress={onClose}
          >            <Text style={styles.cancelText}>취소</Text>          </TouchableOpacity>        </View>      </View>    </Modal>  );};
```

---

## 백엔드 API

### API 1: 결제 링크 생성

```
POST /api/v1/payments/{id}/create-payment-link/

Request Body:
{
  "provider": "toss" | "kakaopay",
  "amount": 280000
}

Response:
{
  "payment_url": "https://pay.toss.im/web/checkout?...",
  "expires_at": "2025-10-27T15:30:00Z"
}
```

**Django 구현 예시**

```python
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from datetime import datetime, timedelta
import urllib.parse
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_payment_link(request, payment_id):
    """외부 결제 링크 생성"""    payment = Payment.objects.get(id=payment_id)
    provider = request.data.get('provider')  # 'toss' or 'kakaopay'    amount = request.data.get('amount', payment.total_amount)
    # 권한 확인 (학부모만 결제 가능)    if request.user.id != payment.group.parent.id:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    # 딥링크 콜백 URL 생성    base_deeplink = "wetee://payment/callback"    success_url = f"{base_deeplink}?payment_id={payment_id}&status=success"    fail_url = f"{base_deeplink}?payment_id={payment_id}&status=failure"    cancel_url = f"{base_deeplink}?payment_id={payment_id}&status=cancelled"    # 주문 ID 생성    order_id = f"wetee_payment_{payment_id}_{datetime.now().strftime('%Y%m%d%H%M%S')}"    order_name = f"{payment.group.student.name} {payment.year}년 {payment.month}월 과외비"    if provider == 'toss':
        # 토스페이 결제 링크 생성        payment_url = generate_toss_payment_link(
            order_id=order_id,
            order_name=order_name,
            amount=amount,
            success_url=success_url,
            fail_url=fail_url
        )
    elif provider == 'kakaopay':
        # 카카오페이 결제 링크 생성        payment_url = generate_kakao_payment_link(
            order_id=order_id,
            order_name=order_name,
            amount=amount,
            approval_url=success_url,
            fail_url=fail_url,
            cancel_url=cancel_url
        )
    else:
        return JsonResponse({'error': 'Invalid provider'}, status=400)
    # 결제 링크 로그 저장    PaymentLog.objects.create(
        payment=payment,
        action='payment_link_created',
        details={
            'provider': provider,
            'order_id': order_id,
            'amount': amount,
            'created_at': datetime.now().isoformat()
        }
    )
    return JsonResponse({
        'payment_url': payment_url,
        'expires_at': (datetime.now() + timedelta(minutes=30)).isoformat()
    })
def generate_toss_payment_link(order_id, order_name, amount, success_url, fail_url):
    """토스페이 결제 링크 생성"""    base_url = "https://pay.toss.im/web/checkout"    params = {
        'orderId': order_id,
        'orderName': order_name,
        'amount': amount,
        'successUrl': success_url,
        'failUrl': fail_url,
        'customerName': '',  # 선택사항    }
    query_string = urllib.parse.urlencode(params)
    return f"{base_url}?{query_string}"def generate_kakao_payment_link(order_id, order_name, amount, approval_url, fail_url, cancel_url):
    """카카오페이 결제 링크 생성"""    # 실제로는 카카오페이 API를 호출하여 tid를 받아야 함    # 여기서는 간단히 URL만 생성    base_url = "https://kapi.kakao.com/payment/ready"    params = {
        'partner_order_id': order_id,
        'item_name': order_name,
        'quantity': 1,
        'total_amount': amount,
        'tax_free_amount': 0,
        'approval_url': approval_url,
        'fail_url': fail_url,
        'cancel_url': cancel_url,
    }
    query_string = urllib.parse.urlencode(params)
    return f"{base_url}?{query_string}"
```

---

### API 2: 결제 결과 처리

```
POST /api/v1/payments/{id}/handle-payment-callback/

Request Body:
{
  "status": "success" | "failure" | "cancelled",
  "transaction_id": "toss_abc123" (optional)
}

Response:
{
  "payment": {
    "id": 123,
    "status": "paid",
    "paid_at": "2025-10-27T14:23:15Z",
    "total_amount": 280000
  }
}
```

**Django 구현 예시**

```python
from django.utils import timezone
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def handle_payment_callback(request, payment_id):
    """딥링크 콜백 처리"""    payment = Payment.objects.get(id=payment_id)
    status = request.data.get('status')  # 'success' | 'failure' | 'cancelled'    transaction_id = request.data.get('transaction_id')
    # 중복 처리 방지 (멱등성 보장)    if status == 'success' and transaction_id:
        existing_log = PaymentLog.objects.filter(
            payment=payment,
            action='payment_success',
            details__transaction_id=transaction_id
        ).first()
        if existing_log:
            # 이미 처리된 요청            return Response({
                'message': 'Already processed',
                'payment': PaymentSerializer(payment).data
            })
    if status == 'success':
        # 결제 성공 처리        payment.status = 'paid'        payment.paid_at = timezone.now()
        payment.external_transaction_id = transaction_id
        payment.save()
        # 로그 기록        PaymentLog.objects.create(
            payment=payment,
            action='payment_success',
            details={
                'transaction_id': transaction_id,
                'paid_at': payment.paid_at.isoformat()
            }
        )
        # 선생님에게 알림 전송        send_notification(
            user=payment.group.teacher,
            title='과외비 입금 완료',
            message=f'{payment.group.student.name} 학생의 {payment.month}월 과외비가 입금되었습니다.',
            notification_type='payment_completed',
            target_entity_type='payment',
            target_entity_id=payment.id        )
    elif status == 'failure':
        # 결제 실패 로그 기록        PaymentLog.objects.create(
            payment=payment,
            action='payment_failed',
            details={
                'transaction_id': transaction_id,
                'failed_at': timezone.now().isoformat()
            }
        )
    elif status == 'cancelled':
        # 결제 취소 로그 기록        PaymentLog.objects.create(
            payment=payment,
            action='payment_cancelled',
            details={
                'transaction_id': transaction_id,
                'cancelled_at': timezone.now().isoformat()
            }
        )
    return Response({
        'payment': PaymentSerializer(payment).data
    })
def send_notification(user, title, message, notification_type, target_entity_type=None, target_entity_id=None):
    """푸시 알림 전송 헬퍼 함수"""    from firebase_admin import messaging
    # FCM 토큰 가져오기    fcm_token = user.profile.fcm_token
    if not fcm_token:
        return    # 알림 DB 저장    notification = Notification.objects.create(
        recipient=user,
        title=title,
        message=message,
        notification_type=notification_type,
        target_entity_type=target_entity_type,
        target_entity_id=target_entity_id,
        is_read=False    )
    # FCM 푸시 전송    message = messaging.Message(
        notification=messaging.Notification(
            title=title,
            body=message,
        ),
        data={
            'notification_id': str(notification.id),
            'type': notification_type,
            'entity_type': target_entity_type or '',
            'entity_id': str(target_entity_id) if target_entity_id else '',
        },
        token=fcm_token,
    )
    try:
        messaging.send(message)
    except Exception as e:
        print(f"FCM send error: {e}")
```

---

## 에러 케이스 및 처리

| 에러 상황 | 감지 방법 | 처리 방법 |
| --- | --- | --- |
| **결제 링크 생성 실패** | API 호출 실패 (500) | “결제 링크 생성에 실패했습니다. 다시 시도해주세요.” 알림 표시 |
| **외부 브라우저/앱 실행 실패** | `Linking.canOpenURL()` returns false | “결제 앱을 실행할 수 없습니다. 토스/카카오페이 앱을 설치해주세요.” 알림 + 앱스토어 링크 제공 |
| **딥링크 파싱 실패** | URL 파싱 에러 발생 | 에러 로그 기록, 사용자에게 “결제 정보 확인 중” 메시지 표시 후 정산 목록으로 이동 |
| **결제 취소 (사용자 의도)** | `status=cancelled` 수신 | “결제가 취소되었습니다.” 알림 표시, 정산 상태 유지 (pending) |
| **결제 실패 (잔액 부족 등)** | `status=failure` 수신 | “결제에 실패했습니다. 결제 수단을 확인해주세요.” 알림 표시, “다시 시도” 버튼 제공 |
| **네트워크 오류** | API 호출 시 네트워크 에러 | 로컬 저장 후 재시도 로직, “네트워크 오류가 발생했습니다. 다시 시도해주세요.” 알림 |
| **딥링크 수신 타임아웃 (5분)** | 5분 경과 후에도 딥링크 미수신 | 백그라운드에서 결제 상태 폴링 (GET /api/v1/payments/{id}/), 자동 UI 업데이트 |

---

## 에러 처리 구현 예시

### 1. 외부 앱 실행 실패 처리

```jsx
const openPaymentApp = async (paymentUrl, provider) => {
  try {
    const canOpen = await Linking.canOpenURL(paymentUrl);    if (!canOpen) {
      // 앱 미설치      Alert.alert(
        '앱 설치 필요',        `${provider === 'toss' ? '토스' : '카카오페이'} 앱이 필요합니다.`,        [
          { text: '취소', style: 'cancel' },          {
            text: '설치하기',
            onPress: () => openAppStore(provider)
          }
        ]
      );      return false;    }
    await Linking.openURL(paymentUrl);    return true;  } catch (error) {
    console.error('Failed to open payment app:', error);    Alert.alert('오류', '결제 앱을 실행할 수 없습니다.');    return false;  }
};const openAppStore = (provider) => {
  const storeUrl = provider === 'toss'    ? Platform.select({
        ios: 'https://apps.apple.com/kr/app/toss/id839333328',        android: 'https://play.google.com/store/apps/details?id=viva.republica.toss'      })
    : Platform.select({
        ios: 'https://apps.apple.com/kr/app/kakaopay/id1464496236',        android: 'https://play.google.com/store/apps/details?id=com.kakaopay.app'      });  Linking.openURL(storeUrl);};
```

### 2. 타임아웃 처리 (백그라운드 폴링)

```jsx
import { useEffect, useRef } from 'react';const usePaymentTimeout = (paymentId, onTimeout) => {
  const timeoutRef = useRef(null);  const pollingRef = useRef(null);  const startTimeout = () => {
    // 5분 타임아웃 설정    timeoutRef.current = setTimeout(() => {
      startPolling();    }, 5 * 60 * 1000);  };  const startPolling = () => {
    // 10초마다 결제 상태 확인    pollingRef.current = setInterval(async () => {
      try {
        const payment = await api.get(`/api/v1/payments/${paymentId}/`);        if (payment.status === 'paid') {
          clearPolling();          onTimeout(payment);        }
      } catch (error) {
        console.error('Polling error:', error);      }
    }, 10000);  };  const clearPolling = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);      timeoutRef.current = null;    }
    if (pollingRef.current) {
      clearInterval(pollingRef.current);      pollingRef.current = null;    }
  };  useEffect(() => {
    return () => clearPolling();  }, []);  return { startTimeout, clearPolling };};// 사용 예시const PaymentScreen = ({ paymentId }) => {
  const { startTimeout, clearPolling } = usePaymentTimeout(
    paymentId,    (payment) => {
      Alert.alert('결제 완료', '결제가 완료되었습니다.');      navigation.navigate('PaymentDetail', { id: paymentId });    }
  );  const handlePaymentStart = async () => {
    // 결제 시작    await openPaymentLink();    // 타임아웃 시작    startTimeout();  };  useEffect(() => {
    return () => clearPolling();  }, []);};
```

### 3. 네트워크 오류 재시도

```jsx
const apiWithRetry = async (apiCall, maxRetries = 3) => {
  let lastError;  for (let i = 0; i < maxRetries; i++) {
    try {
      return await apiCall();    } catch (error) {
      lastError = error;      if (i < maxRetries - 1) {
        // 지수 백오프: 1초, 2초, 4초        await new Promise(resolve =>
          setTimeout(resolve, Math.pow(2, i) * 1000)
        );      }
    }
  }
  throw lastError;};// 사용 예시try {
  const response = await apiWithRetry(
    () => api.post(`/api/v1/payments/${paymentId}/create-payment-link/`, { provider })
  );} catch (error) {
  Alert.alert(
    '네트워크 오류',    '결제 링크 생성에 실패했습니다. 네트워크 연결을 확인해주세요.',    [
      { text: '취소', style: 'cancel' },      { text: '다시 시도', onPress: () => handlePaymentStart() }
    ]
  );}
```

---

## 보안 고려사항

### 1. 딥링크 검증

백엔드에서 payment_id와 transaction_id의 유효성을 검증합니다:

```python
def handle_payment_callback(request, payment_id):
    payment = Payment.objects.get(id=payment_id)
    transaction_id = request.data.get('transaction_id')
    # 1. payment_id 유효성 확인    if not payment:
        return Response({'error': 'Invalid payment_id'}, status=400)
    # 2. 권한 확인 (요청자가 학부모인지)    if request.user.id != payment.group.parent.id:
        return Response({'error': 'Permission denied'}, status=403)
    # 3. transaction_id가 있다면 외부 서비스에서 검증    if transaction_id:
        is_valid = verify_transaction_with_external_service(
            provider=payment.provider,
            transaction_id=transaction_id,
            expected_amount=payment.total_amount
        )
        if not is_valid:
            return Response({'error': 'Invalid transaction'}, status=400)
    # 정상 처리...
```

### 2. 중복 처리 방지 (멱등성)

동일한 transaction_id로 여러 번 호출되어도 한 번만 처리:

```python
def handle_payment_callback(request, payment_id):
    payment = Payment.objects.get(id=payment_id)
    transaction_id = request.data.get('transaction_id')
    # 이미 처리된 transaction인지 확인    if PaymentLog.objects.filter(
        payment=payment,
        action='payment_success',
        details__transaction_id=transaction_id
    ).exists():
        # 중복 요청 - 기존 결과 반환        return Response({
            'message': 'Already processed',
            'payment': PaymentSerializer(payment).data
        })
    # 트랜잭션 내에서 처리    with transaction.atomic():
        payment.status = 'paid'        payment.paid_at = timezone.now()
        payment.save()
        PaymentLog.objects.create(
            payment=payment,
            action='payment_success',
            details={'transaction_id': transaction_id}
        )
```

### 3. URL 파라미터 변조 방지

프론트엔드에서 딥링크 파라미터를 조작하더라도, 백엔드에서 외부 결제 서비스에 재조회하여 검증:

```python
def verify_transaction_with_external_service(provider, transaction_id, expected_amount):
    """외부 결제 서비스에서 거래 정보 조회 및 검증"""    if provider == 'toss':
        # 토스페이 API로 거래 조회        response = requests.get(
            f'https://api.tosspayments.com/v1/payments/{transaction_id}',
            headers={'Authorization': f'Basic {TOSS_SECRET_KEY}'}
        )
        if response.status_code == 200:
            data = response.json()
            # 금액 일치 확인            return data['totalAmount'] == expected_amount
    elif provider == 'kakaopay':
        # 카카오페이 API로 거래 조회        # (구현 생략)        pass    return False
```

### 4. 타임아웃 설정

결제 링크의 유효시간을 30분으로 제한:

```python
def create_payment_link(request, payment_id):
    # ... (생략)    # 결제 링크 생성 시각 저장    PaymentLinkLog.objects.create(
        payment=payment,
        created_at=timezone.now(),
        expires_at=timezone.now() + timedelta(minutes=30),
        is_used=False    )
    return JsonResponse({
        'payment_url': payment_url,
        'expires_at': (timezone.now() + timedelta(minutes=30)).isoformat()
    })
```

---

## 장점

1. **빠른 개발**: PG 연동 대비 **70% 시간 단축** (3-5일 vs 2-3주)
2. **비용 절감**: PG 수수료 없음, 초기 비용 0원
3. **법적 리스크 최소화**: 실제 결제는 외부 서비스에서 처리
4. **핵심 가치 집중**: 정산 투명성이라는 MVP 핵심 가치 검증 가능
5. **사용자 친숙도**: 이미 사용 중인 토스/카카오페이 활용
6. **사업자등록 불필요**: 개인 간 거래로 간주되어 즉시 서비스 시작 가능

---

## 단점 및 한계

1. **딥링크 미수신 가능성**: 앱 전환 과정에서 딥링크가 호출되지 않을 수 있음
    - **대응**: 백그라운드 폴링으로 상태 동기화
2. **결제 상태 동기화 지연**: 실시간 업데이트가 아닌 폴링 방식
    - **대응**: 사용자에게 “확인 중” 메시지 표시
3. **수동 환불 처리**: 자동 환불 불가능
    - **대응**: Phase 1에서는 계좌이체로 환불, Phase 2에서 자동화
4. **결제 추적 제한**: 외부 서비스의 거래 내역에 의존
    - **대응**: PaymentLog로 모든 이벤트 기록
5. **UX 끊김**: 앱 전환으로 인한 사용자 경험 단절
    - **대응**: 딥링크 복귀로 최소화

---

## Phase 2 전환 시 고려사항

Phase 1 딥링크 방식으로 MVP를 검증한 후, Phase 2에서 PG 연동으로 전환할 때:

1. **데이터 마이그레이션**: 기존 결제 로그 유지
2. **API 호환성**: 기존 API 엔드포인트 유지하면서 내부 로직만 변경
3. **점진적 전환**: 딥링크와 PG 결제 병행 운영 가능
4. **사용자 선택권**: “간편 결제” vs “카드 결제” 옵션 제공

---

### 2.6.10 법적 요구사항

**영수증 발급 의무**
- 소득세법에 따라 교육비 영수증 발급 의무
- 발급 거부 시 과태료 부과 가능

**개인정보 보호**
- 결제 정보는 암호화 저장
- 영수증 다운로드 링크는 30일 후 만료

**세금 처리**
- Phase 1에서는 개인 간 거래로 세금 처리 책임 없음
- Phase 2 (PG 연동) 시 사업자등록 필요
- 부가가치세, 소득세 처리 검토 필요

**데이터 보관**
- 정산 기록 최소 5년 보관 (세법)
- 영수증 PDF 최소 5년 보관

### 2.6.11 에러 케이스 및 처리

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 출결 미체크 수업 존재 | “출결이 체크되지 않은 수업이 있습니다” | 정산 생성 보류, 선생님에게 알림 |
| 과외비 미설정 | “시간당 과외비가 설정되지 않았습니다” | 설정 화면으로 이동 유도 |
| 정산 중복 생성 시도 | “이미 해당 월의 정산이 존재합니다” | 기존 정산 표시 |
| 이의 제기 실패 | “이의 제기에 실패했습니다” | 재시도 버튼, 고객센터 안내 |
| 영수증 생성 실패 | “영수증 생성에 실패했습니다” | 재생성 버튼, 관리자에게 알림 |
| PDF 다운로드 실패 | “파일을 다운로드할 수 없습니다” | 재시도, 링크 재발급 |

**권한별 접근 제어**

| 작업 | 선생님 | 학생 | 학부모 |
| --- | --- | --- | --- |
| 정산 조회 | ✅ | ❌ | ✅ |
| 정산 상세 조회 | ✅ | ❌ | ✅ |
| 정산 확인 | ✅ | ❌ | ✅ |
| 이의 제기 | ✅ | ❌ | ✅ |
| 영수증 다운로드 | ✅ | ❌ | ✅ |
| 정산 수동 생성 | ✅ | ❌ | ❌ |
| 정산 삭제 | ❌ | ❌ | ❌ |

**UI/UX 요구사항**
- 정산 내역은 수업 일자별로 명확히 표시
- 각 수업의 출석 상태와 부과 금액 함께 표시
- 총액은 크고 굵게 강조
- 확인 버튼은 하단 고정
- 이의 제기는 쉽게 접근 가능하게
### 2.7 숙제 관리

**기능 ID**: F-007

**개발 우선순위**: 2단계 확장 기능

**기능 목적**
숙제 부여, 제출, 확인의 전 과정을 디지털화하여 분실이나 누락을 방지합니다.

**기능 설명**
선생님이 숙제를 등록하면 학생에게 알림이 전송되고, 학생은 완료 후 사진이나 파일로 제출합니다.

**상세 동작**

1. 숙제 부여
    - 숙제 내용 입력
    - 마감일 설정
    - 첨부 자료 업로드 (선택)
    - 저장 시 학생에게 알림
2. 학생 제출
    - 숙제 사진 촬영 또는 파일 첨부
    - 제출 완료 버튼
    - 제출 시 선생님에게 알림
3. 선생님 확인
    - 제출된 숙제 리스트 조회
    - 간단한 피드백 작성 (선택)
    - 확인 완료 체크
4. 숙제 이행률 통계
    - 월별 제출률 계산
    - 제출 기한 준수율
    - 대시보드에 표시

**UI/UX 요구사항**
- 숙제 제출은 카메라 직접 연동
- 미제출 숙제는 빨간색 표시
- 마감일 하루 전 리마인더 알림

**데이터 모델**
- Homework 테이블: id, group_id, title, description, due_date, attachment_url, assigned_by, assigned_at
- HomeworkSubmission 테이블: id, homework_id, submission_url, submitted_at, feedback

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 중복 제출 시도 | “이미 제출한 숙제입니다” | 기존 제출물 표시, 수정 옵션 제공 |
| 파일 크기 초과 | “파일 크기는 10MB 이하여야 합니다” | 파일 압축 또는 여러 장으로 나눠 제출 안내 |
| 지원하지 않는 파일 형식 | “지원하지 않는 파일 형식입니다” | 지원 형식 안내 (jpg, png, pdf) |
| 마감일 경과 후 제출 | “마감일이 지났습니다. 그래도 제출하시겠습니까?” | 확인 팝업, 지각 제출로 표시 |
| 네트워크 오류로 업로드 실패 | “업로드에 실패했습니다” | 재시도 버튼, 로컬 임시 저장 |

---

### 2.8 학습 진도 추적 대시보드

**기능 ID**: F-008

**개발 우선순위**: 2단계 확장 기능

**기능 목적**
산재된 학습 데이터를 하나의 대시보드에 통합하여 전체적인 학습 상태를 한눈에 파악합니다.

**기능 설명**
출석률, 교재 진도율, 숙제 이행률 등의 정보를 그래프와 차트로 시각화하여 제공합니다.

**상세 동작**

1. 대시보드 구성 (사용자 유형별)
    
    선생님 뷰:
    
    - 학생별 출석률 비교
    - 진도 현황 한눈에
    - 미확인 숙제 개수
    - 이번 달 수업 횟수
    
    학생 뷰:
    
    - 내 출석률
    - 교재 진도율
    - 숙제 제출률
    - 최근 피드백
    
    학부모 뷰:
    
    - 자녀 출석률
    - 교재 진도율
    - 숙제 제출률
    - 이번 달 수업 횟수 및 정산 예상 금액
2. 시각화 요소
    - 원형 그래프 (출석률)
    - 프로그레스 바 (진도율)
    - 라인 차트 (주차별 추이)
    - 캘린더 히트맵 (출석 기록)
3. 기간 필터
    - 이번 주/이번 달/최근 3개월 선택
    - 커스텀 기간 설정 가능

**UI/UX 요구사항**
- 앱 실행 시 첫 화면
- 스크롤 없이 주요 지표 한눈에
- 각 지표 클릭 시 상세 페이지로

**데이터 모델**
- 기존 테이블 데이터를 집계하여 표시
- 별도 테이블 불필요 (쿼리로 처리)

---

### 2.9 오프라인 오답 태그

**기능 ID**: F-009

**개발 우선순위**: 2단계 확장 기능

**기능 목적**
오답을 체계적으로 데이터화하여 학생의 취약점을 정확히 진단하고 전략적 학습을 가능하게 합니다.

**기능 설명**
학생이 틀린 문제를 촬영하고 태그를 붙여 저장하면, 개인화 디지털 오답 노트가 구축됩니다.

**상세 동작**

1. 오답 촬영
    - 카메라로 틀린 문제 촬영
    - 이미지 자동 저장
2. 영역 지정 (선택)
    - 이미지에서 문제 영역만 크롭
    - OCR로 문제 번호 자동 인식 (선택)
3. 태그 붙이기
    - 미리 정의된 태그 선택
        - 계산 실수
        - 개념 이해 부족
        - 시간 부족
        - 문제 이해 실패
        - 기타
    - 커스텀 태그 추가 가능
    - 여러 태그 동시 선택 가능
4. 오답 노트 조회
    - 태그별 필터링
    - 날짜별 정렬
    - 교재별 그룹핑
    - 오답 통계 (태그별 빈도)

**UI/UX 요구사항**
- 촬영부터 저장까지 30초 이내
- 태그는 버튼 형태로 큰 사이즈
- 오답 노트는 갤러리 형태

**데이터 모델**
- WrongAnswer 테이블: id, student_id, image_url, tags (JSON), textbook_id, page, created_at

---

### 2.10 안건함 (알림·할일 통합 관리)

**기능 ID**: F-010 (이전 F-011에서 재정렬)

**개발 우선순위**: 2단계 확장 기능

**기능 목적**
흩어진 알림과 할일을 한 곳에서 관리하여 중요한 액션 아이템을 놓치지 않도록 합니다.

**기능 설명**
모든 알림과 해야 할 일을 통합하여 우선순위 순으로 정렬합니다.

**상세 동작**

1. 알림 수집
    - 일정 변경 알림
    - 숙제 마감 알림
    - 정산 알림
    - 출결 체크 알림
    - 수업 기록 작성 알림
2. 할일 목록
    - 오늘 할 일 (출결 체크, 수업 기록 등)
    - 이번 주 할 일 (숙제 확인, 정산 등)
    - 기한 지난 항목 (빨간색 표시)
3. 우선순위 정렬
    - 긴급 (빨강): 오늘 마감
    - 중요 (주황): 3일 이내 마감
    - 보통 (회색): 그 외
4. 완료 처리
    - 체크박스 클릭으로 완료
    - 완료 항목은 자동 아카이브

**UI/UX 요구사항**
- 앱 상단에 안건 개수 뱃지 표시
- 리스트는 카드 형태
- 스와이프로 완료 처리

**데이터 모델**
- Agenda 테이블: id, user_id, type, content, priority, due_date, status, created_at

---

### 2.11 커뮤니티 (채팅·게시판)

**기능 ID**: F-011 (이전 F-012에서 재정렬)

**개발 우선순위**: 3단계 고도화 기능

**기능 목적**
과외 생태계 내 소통을 활성화하고, 향후 지역 기반 커뮤니티로 확장할 기반을 마련합니다.

**기능 설명**
과외 그룹 내에서 실시간 채팅과 게시판으로 소통합니다.

**상세 동작**

1. 그룹 채팅
    - 과외 그룹별 채팅방 자동 생성
    - 실시간 메시지 전송
    - 이미지/파일 첨부 가능
2. 게시판
    - 공지사항 게시
    - 학습 자료 공유
    - 댓글 기능
3. 지역 커뮤니티 (향후 확장)
    - 동일 지역 사용자 간 소통
    - 과외 정보 교환
    - 교재 공유 장터

**UI/UX 요구사항**
- 채팅은 카카오톡 스타일
- 읽지 않은 메시지 뱃지
- 알림 on/off 설정

**데이터 모델**
- ChatMessage 테이블: id, group_id, sender_id, message, attachment_url, sent_at
- Post 테이블: id, group_id, author_id, title, content, created_at

---

### 2.12 프로필 및 설정

**기능 ID**: F-012 (이전 F-013에서 재정렬)

**개발 우선순위**: 1단계 MVP (필수)

**기능 목적**
사용자의 기본 정보 관리와 앱 사용 환경 설정을 제공합니다.

**기능 설명**
프로필 조회 및 수정, 앱 설정 조정 기능을 제공합니다.

**상세 동작**

1. 프로필 관리
    - 프로필 사진 업로드
    - 기본 정보 수정 (이름, 전화번호 등)
    - 과외 선생님: 경력, 전공, 자기소개 작성
    - 학생: 학년, 목표 설정
2. 앱 설정
    - 알림 수신 여부 (전체/개별)
    - 알림 수신 시간 설정
    - 언어 선택
    - 테마 (라이트/다크 모드)
3. 계정 관리
    - 비밀번호 변경
    - 로그아웃
    - 회원 탈퇴

**UI/UX 요구사항**
- 프로필은 우측 상단 아이콘으로 접근
- 설정은 리스트 형태
- 중요 설정은 확인 팝업

**데이터 모델**
- User 테이블에 추가 컬럼: profile_image, bio, settings (JSON)

**에러 케이스 및 처리**

| 에러 상황 | 에러 메시지 | 처리 방법 |
| --- | --- | --- |
| 프로필 사진 업로드 실패 | “이미지 업로드에 실패했습니다” | 재시도 버튼, 파일 크기/형식 확인 안내 |
| 비밀번호 변경 실패 (현재 비밀번호 불일치) | “현재 비밀번호가 일치하지 않습니다” | 다시 입력 요청 |
| 회원 탈퇴 시도 (미결제 정산 존재) | “정산되지 않은 과외비가 있습니다” | 정산 완료 후 탈퇴 안내 |

---

### 2.13 고객 혜택 제도

**기능 ID**: F-013 (이전 F-014에서 재정렬)

**개발 우선순위**: 3단계 고도화 기능

**기능 목적**
사용자 리텐션을 높이고 지속적인 서비스 이용을 유도합니다.

**기능 설명**
다양한 활동에 대해 포인트를 적립하고 과외비 할인 등으로 전환할 수 있습니다.

**상세 동작**

1. 포인트 적립
    - 3개월 연속 사용: 1000P
    - 리뷰 작성: 500P
    - 친구 추천: 2000P
    - 출석률 100%: 1000P
2. 포인트 사용
    - 과외비 할인 (1P = 1원)
    - 교육 상품권 교환
    - 제휴 서비스 할인
3. 포인트 내역
    - 적립/사용 내역 조회
    - 현재 보유 포인트 표시

**UI/UX 요구사항**
- 포인트는 메인 화면에 표시
- 적립 시 축하 애니메이션
- 사용 가능 혜택 리스트

**데이터 모델**
- Point 테이블: id, user_id, amount, type, description, created_at

---

## 3. 개발 우선순위 (리서치 결과 반영)

**우선순위 재배치 근거**
온라인 리서치 결과, 과외비 정산이 압도적인 1순위 페인 포인트로 확인되었으며, 진도 공유 및 학부모 소통의 중요도가 예상보다 높게 나타났습니다. 반면 오답 관리는 수요가 낮고, 감정 알림은 사용자 수요가 전무하여 MVP에서 완전히 제거합니다.

### 3.1 1단계: MVP (필수 기능) - 신뢰 및 위험 관리 중심

목표: 금전적 마찰 해소 및 투명성 확보를 통한 신뢰 구축

기간: 3-4개월

핵심 가치: “신뢰 및 위험 관리 플랫폼”

**포함 기능 (6개)**

**P0 (최우선 - 핵심 가치 제공)**
- F-006: 과외비 자동 정산 (1순위) ⬆️
- 리서치 검증: 모든 보고서에서 1순위 페인 포인트로 확인
- Escrow(안전 정산) 시스템 검토 포함
- 법적 분쟁 방지 기능 강화

- F-001: 회원 관리 및 매칭
    - 삼자(선생님-학생-학부모) 연결 구조 명확화
- F-002: 실시간 수업 스케줄 관리
    - 전체 일정 캘린더 뷰 추가 (향후 수업 한눈에)
    - 자동 알림/리마인더 기능 통합
    - 수업 전 알림, 일정 변경 알림
- F-003: 출결 관리 시스템
    - 정산의 기초 데이터로 연동 강화

**P1 (중요 - 차별화 요소)**
- F-005: 수업 직후 기록 + 학부모 포털 ⬆️
- 리서치 검증: 진도 공유 니즈 예상보다 높음
- 학부모 실시간 확인 기능 강화
- 수업 리포트 자동 공유 시스템
- 학부모 전용 대시보드 (읽기 전용)

- F-012: 프로필 및 설정

**개발 순서 (수정)**
1주차: 프로젝트 세팅, 기술 스택 확정

2-4주차: 회원 관리 (삼자 연결 구조)

5-7주차: **과외비 자동 정산 시스템 (최우선)**

8-10주차: 스케줄 관리 + 출결 관리 (캘린더 뷰 + 알림)

11-13주차: 수업 기록 + 학부모 포털

14-15주차: 프로필 및 설정

16주차: 통합 테스트 및 버그 수정

### 3.2 2단계: 확장 기능

목표: 학습 관리 기능 보완

기간: 2-3개월

**포함 기능**
- F-004: 교재 진도율 동기화 ⬇️
- 세밀한 페이지 추적은 1단계 이후 검증 후 구현
- 간단한 진도 기록은 F-005에 포함

- F-007: 숙제 관리 ⬇️
    - 리서치 검증: 중요하나 핵심 페인 포인트는 아님
- F-008: 학습 진도 추적 대시보드
- F-010: 안건함

### 3.3 3단계: 고도화 기능

목표: 생태계 확장 및 수익화

기간: 3-6개월

**포함 기능**
- F-011: 커뮤니티
- F-013: 고객 혜택 제도 ⬇️

**제거 검토 대상 (리서치 결과 수요 낮음)**
- F-009: 오프라인 오답 태그 ⬇️⬇️
- 리서치 검증: 커뮤니티 언급 거의 없음
- 사용자 수요 낮음
- 3단계 이상으로 연기 또는 완전 제거 검토

### 3.4 MVP에서 완전히 제거된 기능

**F-010 감정 알림 (심리·소통) - 완전 제거 ❌**

**제거 이유:**
- 리서치 검증: 사용자 수요 전무
- 온라인 리서치 및 인터뷰에서 해당 기능에 대한 요구사항 0건
- 학생들이 감정을 앱으로 기록하는 것에 대한 거부감
- 선생님과 학부모도 이 기능의 필요성을 느끼지 못함
- 개발 리소스를 핵심 기능(정산, 투명성)에 집중하기 위해 제거

**대안:**
- 수업 기록(F-005)의 “특이사항” 항목에서 선생님이 학생의 학습 태도나 정서 상태를 기록
- 필요 시 채팅(F-011)을 통해 선생님-학부모 간 학생 상태 소통
- 추후 실제 사용자 피드백이 있을 경우에만 재검토

**기능 ID 정리:**
- 이전 F-011 (안건함) → 현재 F-010
- 이전 F-012 (커뮤니티) → 현재 F-011
- 이전 F-013 (프로필) → 현재 F-012
- 이전 F-014 (고객 혜택) → 현재 F-013

---

## 4. 기능 간 연관성

### 4.1 데이터 연결 구조

**출결 관리 → 정산**
- 출결 기록이 정산 계산의 기초 데이터
- 출석 및 지각만 정산에 포함, 결석 제외

**스케줄 → 출결 → 수업 기록**
- 스케줄이 생성되면 출결 체크 가능
- 출결 체크 후 수업 기록 작성
- 하나의 수업 세션으로 통합 표시

**진도 → 대시보드**
- 진도 데이터가 대시보드에 자동 반영
- 시각화된 그래프로 표시

**숙제 → 대시보드**
- 숙제 이행률이 대시보드에 표시
- 학습 태도 평가 지표로 활용

**안건함 → 모든 기능**
- 모든 알림이 안건함으로 수집
- 할 일 목록도 안건함에서 관리

### 4.2 알림 트리거 맵 (완전판)

### 성공 케이스 알림

| 이벤트 | 알림 대상 | 알림 내용 | 우선순위 |
| --- | --- | --- | --- |
| 일정 생성 | 학생, 학부모 | “새로운 수업 일정이 등록되었습니다” | 보통 |
| 일정 변경 | 학생, 학부모 | “수업 일정이 변경되었습니다” | 높음 |
| 일정 취소 | 학생, 학부모 | “수업이 취소되었습니다” | 높음 |
| 수업 1시간 전 | 선생님, 학생 | “1시간 후 수업이 있습니다” | 보통 |
| 출석 체크 (출석) | 학부모 | “자녀가 수업에 출석했습니다” | 보통 |
| 출석 체크 (지각) | 학부모 | “자녀가 10분 지각했습니다” | 보통 |
| 출석 체크 (결석) | 학부모 | “자녀가 수업에 결석했습니다” | 높음 |
| 수업 기록 작성 | 학생, 학부모 | “오늘 수업 내용이 기록되었습니다” | 보통 |
| 진도 입력 | 학생, 학부모 | “교재 진도가 업데이트되었습니다” | 낮음 |
| 숙제 부여 | 학생 | “새로운 숙제가 있습니다” | 보통 |
| 숙제 마감 1일 전 | 학생 | “내일까지 숙제를 제출하세요” | 높음 |
| 숙제 마감일 | 학생 | “오늘까지 숙제를 제출하세요” | 긴급 |
| 숙제 제출 | 선생님 | “학생이 숙제를 제출했습니다” | 보통 |
| 숙제 피드백 작성 | 학생 | “선생님이 피드백을 남겼습니다” | 보통 |
| 정산 생성 | 학부모 | “이번 달 과외비가 확정되었습니다” | 높음 |
| 정산 생성 | 선생님 | “이번 달 정산이 완료되었습니다” | 보통 |
| 결제 링크 생성 | 학부모 | "결제 링크가 생성되었습니다. 클릭하여 결제해주세요.” | 높음 |
| 결제 완료 (딥링크 복귀) | 학부모, 선생님 | "결제가 완료되었습니다.” | 높음 |
| 결제 완료 | 선생님 | “과외비가 입금되었습니다” | 높음 |
| 영수증 발급 | 학부모, 선생님 | “영수증이 발급되었습니다” | 낮음 |

### 에러/실패 케이스 알림

| 이벤트 | 알림 대상 | 알림 내용 | 우선순위 |
| --- | --- | --- | --- |
| 정산 자동 생성 실패 | 선생님 | “정산 생성에 실패했습니다. 수동으로 확인해주세요” | 긴급 |
| 출결 미체크 (수업 종료 2시간 후) | 선생님 | “출결을 체크하지 않은 수업이 있습니다” | 높음 |
| 수업 기록 미작성 (수업 종료 24시간 후) | 선생님 | “수업 기록을 작성하지 않았습니다” | 보통 |
| 숙제 마감일 경과 미제출 | 학생 | “제출하지 않은 숙제가 있습니다” | 높음 |
| 결제 실패 | 학부모 | “결제에 실패했습니다. 결제 수단을 확인해주세요” | 긴급 |
| 결제 재시도 필요 | 학부모 | “결제를 다시 시도해주세요” | 높음 |
| 영수증 생성 실패 | 선생님 | “영수증 생성에 실패했습니다. 관리자에게 문의하세요” | 보통 |
| 정산 금액 이의 제기 | 선생님, 학부모 | “정산 내역 확인 요청이 접수되었습니다” | 높음 |
| 출결 데이터 누락 (정산 시) | 선생님 | “출결이 체크되지 않은 수업이 있어 정산이 보류되었습니다” | 긴급 |

### 시스템 알림

| 이벤트 | 알림 대상 | 알림 내용 | 우선순위 |
| --- | --- | --- | --- |
| 매월 1일 정산 시작 | 선생님 | “이번 달 정산이 시작됩니다” | 보통 |
| 보강 일정 제안 | 학부모 | “보강 일정을 확인해주세요” | 보통 |
| 보강 일정 승인 | 선생님, 학생 | “보강 일정이 확정되었습니다” | 보통 |
| 장기 미접속 (2주) | 선생님 | “오랜만입니다. 최근 수업 현황을 확인해보세요” | 낮음 |
| 출석률 100% 달성 | 학생, 학부모 | “축하합니다! 이번 달 출석률 100%를 달성했습니다” | 낮음 |

**알림 우선순위 정의:**
- **긴급**: 즉시 확인 필요, 진동 + 소리, 앱 상단 빨간 배너
- **높음**: 빠른 확인 권장, 진동 + 소리, 앱 내 알림
- **보통**: 일반 확인, 진동만, 앱 내 알림
- **낮음**: 확인 선택, 무음, 앱 내 알림만

---

## 5. 기술 요구사항 (개략)

### 5.1 필수 기술 기능

**인증 및 권한**
- 이메일/전화번호 인증
- JWT 기반 토큰 인증
- 사용자 유형별 권한 관리 (선생님/학생/학부모)

**실시간 기능**
- 푸시 알림 (FCM)
- 실시간 데이터 동기화
- 알림 우선순위별 다른 처리

**파일 처리**
- 이미지 업로드 (프로필, 숙제, 오답)
- PDF 생성 (영수증, 출결 리포트)
- 파일 크기 제한 및 압축

**데이터 시각화**
- 그래프 및 차트 라이브러리
- 진도율, 출석률 계산 및 표시

**결제**

- Phase 1: 딥링크 기반 외부 결제 (토스/카카오페이) ⭐ NEW
    - React Native Linking API 활용
    - 딥링크 URL 스키마: `wetee://payment/callback`
    - 결제 완료/실패 시 자동 앱 복귀
    - 외부 결제 링크 생성 API (토스/카카오페이)
    - 딥링크 수신 및 파싱 로직
    - 결제 상태 동기화 (실시간/폴링)
- Phase 2: PG사 연동 (추후 단계)
    - 토스페이먼츠/이니시스/KG이니시스 등
    - 카드/계좌이체 직접 결제
    - 자동 정산 및 입금
- 공통: 결제 에러 처리
    - 결제 실패 시 재시도 로직
    - 딥링크 수신 타임아웃 처리 (5분)
    - 네트워크 오류 시 백그라운드 폴링
    - 중복 결제 방지 (멱등성 보장)

**에러 처리**
- 전역 에러 핸들러
- 네트워크 오류 시 로컬 저장 및 재시도
- 사용자 친화적 에러 메시지

### 5.2 성능 요구사항

- 앱 로딩 시간: 2초 이내
- 출결 체크 응답: 1초 이내
- 이미지 업로드: 5초 이내 (3MB 기준)
- 알림 전송 지연: 5초 이내
- API 응답 시간: 500ms 이내 (95 percentile)

### 5.3 보안 요구사항

- 개인정보 암호화 저장
- HTTPS 통신 필수
- SQL Injection 방지
- XSS 방지
- 비밀번호 해싱 (PBKDF2)
- JWT 토큰 만료 및 갱신

---

## 6. 향후 고려사항

### 6.1 확장 가능성

**B2B 전환**
- 학원/교육기관용 대시보드
- 다수 선생님 관리 기능
- 기관 통계 리포트

**AI 기능**
- 학습 패턴 분석
- 맞춤 학습 추천
- 자동 진도 예측

**지역 커뮤니티**
- 지역별 과외 정보 공유
- 교재 거래 장터
- 스터디 그룹 매칭

### 6.2 수익화 전략

**프리미엄 모델**
- 기본 기능: 무료
- 고급 기능: 월 9,900원
* 대시보드 고급 분석
* 과거 데이터 무제한 조회
* AI 학습 추천

**수수료 모델**
- 앱 내 결제 시 수수료 (2-3%)

**광고 모델**
- 교육 관련 배너 광고 (신중 검토)

---

## 7. 문서 변경 이력

**v2.2 (2025-10-25)** ⭐ NEW
- F-001 회원 관리 및 매칭 기능 대폭 상세화 (48줄 → 550줄)
- 삼자 관계 구조 다이어그램 추가
- 초대 코드 시스템 상세 명세 (6자리, 7일 만료, 최대 2회 사용)
- 회원가입 플로우 단계별 상세 설명 (선생님 4단계, 학생/학부모 3단계)
- 이메일 인증 프로세스 추가
- 권한 관리 체계 매트릭스 추가
- API 엔드포인트 예시 6개 추가 (회원가입, 로그인, 초대 코드 검증 등)
- 데이터 모델 상세 명세 (User, Profile, TutoringGroup)
- UI/UX 화면 예시 3개 추가 (사용자 선택, 초대 코드 입력, 코드 공유)
- 에러 케이스 확장 (6개 → 12개)
- 그룹 탈퇴 및 계정 삭제 정책 추가
- 보안 고려사항 추가
- 회원관리 상세 설계서(WeTee_회원관리_및_매칭_시스템_상세_설계서.md) 내용 통합

**v2.1 (2025-10-24)**
- F-006 과외비 자동 정산의 MVP 범위 명확화
- “알림 및 결제” → “알림 및 확인”으로 변경
- 앱 내 결제 기능 제외 (Phase 2로 연기)
- “결제 실행” 권한 삭제, “정산 확인” 권한 추가
- 에러 케이스에서 결제 관련 항목 제거
- 오프라인 결제 방식 명시 (계좌이체/현금/토스 송금링크)

**v2.0 (2025-10-23)**
- 모든 MVP 핵심 기능에 에러 케이스 및 처리 방법 추가
- F-004 교재 진도율에 권한별 접근 제어 테이블 명시
- 알림 트리거 맵 확장 (성공/에러/시스템 알림 구분, 우선순위 정의)
- F-010 감정 알림 기능 MVP에서 완전 제거 (사용자 수요 검증 실패)
- 기능 ID 재정렬 (F-011→F-010, F-012→F-011, F-013→F-012, F-014→F-013)
- 권한 매트릭스 테이블 추가 (F-002, F-003, F-004, F-005, F-006)

**v1.0 (2025-10-21)**
- 초기 기능 명세서 작성
- 14개 기능 정의
- 우선순위 설정

---

**문서 버전**: v2.4

**최종 수정일**: 2025-10-27 (v2.4)

**작성자**: 프로젝트 기획팀

**다음 업데이트**: 개발 착수 후 실제 구현 사항 반영 (v2.5 예정)